---
title:  "OC review"
date:   2016-03-17 19:50:00 +8:00
categories: Objective-C
tags: [OC]
---
## 面向对象和面向过程

`OC` 是一门面向对象的语言, 在学习之前, 应该先了解面向对象的概念.

面向对象:

- 特点: 分析解决问题的步骤, 实现函数, 依次调用函数.
- 侧重点: 实现功能.
- 语言: `OC`, `C++`, `Java` 等.

面向过程:

- 特点: 分析该问题需要参与的对象, 各个对象的功能, 完成该事件需要多个对象协同完成任务.
- 侧重点: 对象的设计.
- 语言: `C`.

面向对象的优点:

- 面向对象具有良好的可扩展性和重用性.
- 面向对象可以降低代码的耦合度, 提高代码的可移植性.
- 面向对象接近于日常生活和自然的思考方式, 可以提高软件开发的效率和质量.

## OC 

`Objective-C` 简称 `OC`, `OC` 是 `C` 语言的扩充.

`OC` 语言的特点:

- `C` 语言的超集, 允许在 `OC` 中使用 `C` 语言代码, 编译器兼容 `C` 语言程序.
- 具备完善的面向对象特征: 封装, 继承, 多态.

`OC` 中使用的是消息发送机制: [receiver message].

消息发送机制: 给对象或者类发送方法名称以及携带的参数, 对象或类接收到到消息, 找到方法, 并且执行.

## 类和对象

类: 具有相同特征和行为的事物的抽象, 是对象的类型.

类的定义过程需要进行分文件放置, 分为 `.h` 和 `.m` 文件.

`.h` 文件管理类的接口部分, `.m` 文件管理类的实现部分.

对象: 对象是类的实例, 万事万物皆对象.

对象的创建需要两部, 分配空间和初始化.

分配空间方法

```objc
+ (instancetype)alloc;
```

`+` 表示方法是类方法, 只能由类调用. 实例变量不能在类方法中使用.

初始化方法

```objc
- (instancetype)init;
```

`-` 表示方法是对象方法, 只能由对象调用. 实例变量能在对象方法中使用.

> 类中不能出现同名方法.

## instancetype 和 id 的区别

`instancetype` 可以返回和方法所在类相同类型的对象, `id` 只能返回未知类型的对象.

`instancetype` 只能作为返回值和参数, `id` 还可以用来定义变量.

## 实例变量三种可见度的区别

- `@public` : 本类可以访问, 子类可以访问, 其他类可以访问.

- `@private` : 本类可以访问, 子类不可以访问, 其他类不可以访问.

- `@protected` : 本类可以访问, 子类可以访问, 其他类不可以访问.

以上的可以访问或不可以访问, 是指可以直接访问或不可以直接访问.

## setter 和 getter

`setter` : 为单一实例变量赋值的方法

`getter` : 获取单一实例变量值得方法

`OC` 中规定了 `setter` 和 `getter` 的书写格式

`setter` : `set` + 首字母大写的实例变量名

`getter` : 方法名与变量名相同

## 继承

继承既能保证类的完整, 又能简化代码.

继承自其他类的叫子类, 被继承的叫超类(父类), 一个类只能有一个超类, 可以有多个子类.

如果需要创建多个有一些相同方法或者实例变量的类, 只需要把公共的方法写在一个类里面, 其他类继承这个超类, 各自实现自己的独有的方法和实例变量即可.

> `NSObject` 有一个 `isa` 属性, 因为每个类的始祖类都是 `NSObject`, 所以都继承了 `isa` 属性. `isa` 属性是一个指针类型, 指向自己的父类, 也就是说. 因为 `NSObject` 为基类, 所以它的 `isa` 指针指向 `nil`.

> 还需要注意一点的是,  使用 `runtime` 时, 可以发现, 在一个类中不止指针 `isa`, 还有一个为 `Class` 的变量 `isa`. 变量 `isa` 指向的是当前类的实际类型.

## super 和 self

`self` : 如果在类方法中, 即指这个类. 如果在实例方法中, 即指这个实例.

`super` : 不是一个对象, 只是一个编译器指令, 特指超类.

## 初始化方法

需要先初始化超类中继承的实例变量, 再初始化自身的实例变量, 才能完全初始化自身的所有实例变量.

## 属性

`@property` 用来声明属性.

提供 `setter` 和 `getter` 方法的声明, 即声明了属性, 编译器会自动完成 `setter` 和 `getter` 方法的声明.

`@synthesize` 用来实现属性.

提供 `setter` 和 `getter` 方法的实现, 即实现了属性, 编译器会自动完成 `setter` 和 `getter` 方法的实现.

注: 在 `Xcode4.5` 以及之后的版本中, `@synthesize` 可以省略, 只使用 `@property` 声明属性.

`@dynamic` 用来表示 `setter` 和 `getter` 方法由自己实现.

> - 属性的作用是生成 `setter` 和 `getter`, 如果方法内部操作的实例变量未定义, 系统会自动生成一个`_`属性名的实例变量, 但是生成的实例变量的可见度是私有的, 子类不可访问.
- 一旦同时重写了 `setter` 和 `getter` 方法, 并且没有实现 `@synthesize`, `@synthesize` 就不再生成实例变量.

1. 同时重写了 `setter` 和 `getter` 方法时, 需要用 `@synthesize` 来关联实例变量和方法.
2. 重写了只读属性的 `getter` 时, 也需要使用 `@synthesize` 来关联实例变量和方法.
3. 使用了 `@dynamic`, 需要用户去自己实现 `setter` 和 `getter` 方法时, 需要使用 `@synthesize` 来关联实例变量和方法.

## 属性特征

读写性:

- `readonly`: 只读状态, 只生成 `getter` 方法.
- `readwrite`: 读写状态, 生成 `setter` 和 `getter` 方法.
- `setter`: 指定属性生成的 `setter` 方法的名字.
- `getter`: 指定属性生成的 `getter` 方法的名字.

原子性:

- `atomic`: `setter` 和 `getter` 方法在多线程访问下是绝对安全的. 如果不声明, 系统默认选择.
- `nonatomic`: `setter` 和 `getter` 方法内部不会做多线程访问处理.

语义特性:

- `assgin`: 属性是非对象类型时使用, 不更改引用计数.
- `retain`: 属性是对象类型时使用. 指向的内存区域引用计数加一.原内存地址引用计数减一, 属于浅拷贝, 即内存地址拷贝.
- `copy`: 属性是对象类型时使用, 深拷贝得到对象的副本, 指针指向副本的地址, 而不是原内存地址. 副本内存地址引用计数加一. `setter` 方法中执行 `copy` 方法.

> 如果想要自己的类使用 `copy` 修饰符, 应该遵从 `NSCoping` 协议, 并且实现 `- (id)copyWithZone:(NSZone *)zone;` 方法.

ARC下的新特性:

- `strong`: 类似于 `retain` , 当声明 `strong` 的指针指向一个内存区域时, 这个内存区域的*引用计数+ 1*.
- `weak`: `weak` 指向内存区域时, 这个内存区域的*引用计数不会加一*, 而且当指向的内存区域被释放掉的时候, `weak` 的指针自动赋值为 `nil`.
- `unsafe_unretained`: 这个修饰的指针, 也不会使指向的内存区域引用计数增加, 但是当指向的内存区域被释放时, 指针不会自动赋值为 `nil`, 所以很容易造成空指针.

## 点语法

- 赋值: 调用 `setter` 方法.
- 取值: 调用 `getter` 方法.

## 常用类型

`NSString`: 字符串类型, 有可变类型.
`NSArray`: 数组类型, 排列有序, 有可变类型.
`NSDictionary`: 字典类型, 排列无序, 有可变类型.
`NSSet`: 集合类型, 排列无序, 用于计算对象的个数. 在集合中不能有相同的对象.
`NSNumber`: 对象数值类型, 将非对象数值转换为对象类型.
`NSValue`: 对象结构体类型, 将非对象结构体转换为对象类型.

## 集合遍历

- `for` 循环遍历
- `NSNumerator` 枚举器遍历
- `for...in` 遍历, 是在枚举器的基础上封装的更简便的遍历, 在便利的过程中*不能改变元素的个数*.

## 数组排序

- `NSSortDescriptior` 实现排序, 把元素的某个属性作为 `key` 进行升序或降序的排序, 每个 `NSSortDescriptor` 对象就是一个排序条件.

```objc
// 参数1: 属性名 参数2: YES 为升序, NO 为降序
- (instancetype)initWithKey:(NSString *)key ascending:(BOOL)ascending;

// 数组根据排序条件进行排序, 得到排好序的新的数组对象.
- (NSArray *)sortedArrayUsingDescriptors:(NSArray *)sortDescriptors;
```

其他数组排序方法

```objc
// SEL 类型的参数 comparator: 需要传入一个返回结果是 NSComparisionResult 的方法名
- (NSArray *)sortedArrayUsingSelector:(SEL)comparator;
```

## 内存管理方式

- `GC`: 垃圾回收机制
- `MRC`: 手动开辟内存空间, 手动释放内存空间.
- `ARC`: 手动开辟内存空间, 系统根据情况自动释放内存空间.

`ARC` 基于 `MRC`, `MRC` 使用引用计数机制管理内存, 之后当引用计数清零时, 内存空间才会释放.

引用计数机制, 当创建时, 内存空间的引用计数为1, 有指针指向这个内存空间时, 此内存空间引用计数加1, 当引用计数为零时, 内存空间释放(销毁).

`autorelease` 标记的内存, 会随着自动释放池销毁而一起释放, 在没有声明自动释放池的情况下, 会在 `runloop` 一个运行周期结束后释放.

当两个对象都用 `strong` 或者 `retain` 声明的时候, 应该尽量避免循环引用, 从而发生互相都在等待释放.

- 浅拷贝: 只拷贝内存地址, 不拷贝内容.
- 深拷贝: 重新开辟一个空间, 并将原空间内的内容拷贝一份到新空间.

> 注意! 当需要将一个可变数组直接赋值给不可变数组时, 最好将不可变数组声明中加上 `copy`, 这是为了使不可变数组不随着可变数组一起变化, 使两个数组成为独立的个体. 当容器执行深拷贝的时候, 容器中的元素, 即指针只会执行浅拷贝, 而不会开辟空间来储存元素.

## 协议

协议是一套标准, 或者一堆方法的声明.

接收协议的方式为指定代理对象.

代理对象用 `assign` 或者 `weak` 修饰, 防止循环引用.

协议声明用 `@protocol`, 必须实现的方法用 `@required` 声明, 可选择实现的方法用 `@optional` 声明.

## KVC

`Key Value Coding` 键值编码, 是一种简介访问实例变量的方法.

`KVC` 中常用的方法:

```objc
- (id)valueForKey:(NSString *)key;
- (void)setValue:(id)value forKey:(NSString *)key;
- (id)valueForKeyPath:(NSString *)keyPath;
- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;
- (void)setValuesForKeysWithDictionary:(NSDictionary *)keyedValues;
```

## 类扩展

`category` 也叫类目

- 是为没有源代码的类扩充功能.
- 扩充的功能会成为原有类的一部分, 可以通过原有类或者原有类的对象直接调用, 并且可以继承.
- 只扩充方法, 不能扩充实例变量.

`Extension` 也叫延展

- 为能够获得源代码的类添加私有的实例变量和方法.
- 操作的类必须是能够获得源代码的类.

## 设计模式

- `MVC` 框架级设计模式
- `ViewController` 中介者模式
